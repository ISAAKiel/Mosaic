---
title       : Modelling Interaction
subtitle    : Distances
author      : Oliver Nakoinz, Daniel Knitter
date: Workshop, 07.09.2016, 08:00-10:00, MOSAIC summer school, Kiel
job         : MOSAIC Summer School 2016
framework   : io2012        # {io2012, html5slides, shower, dzslides, ...}
highlighter : highlight.js  # {highlight.js, prettify, highlight}
hitheme     : tomorrow # tomorrow 
widgets     : [mathjax, phantomjs]            # {mathjax, quiz, bootstrap}
mode        : selfcontained # {standalone, draft}
knit        : slidify::knit2slides
logo        : logo03.png
biglogo     : logo03.png
--- 

<style type="text/css">
body {background:grey transparent;
}
</style>

## Content

> 1. Prerequisites: load data into R, calculate simple geomorphometric measures
> 2. Euclidean distance
> 3. Least-cost distance

---

## Content

1. **Prerequisites: load data into R, calculate simple geomorphometric measures**
2. Euclidean distance
3. Least-cost distance

---

## 1.1 Download DEM

As test data, I download the data provided with the book of Nakoinz and Knitter (2016):

```{r}
download.file(
    url = "https://raw.githubusercontent.com/dakni/mhbil/master/data/dw_gk3_50_ag.asc",
    destfile = "dem.asc")
```

Now, load the file using `rgdal` package

```{r results='hide', message=FALSE}
library(rgdal)
dem <- readGDAL("dem.asc")
```

---

## 1.1 Download DEM

Structure of the `dem` object

```{r collapse=TRUE}
str(dem)
```

--- &twocol

## 1.1 Where is the DEM?

*** =left

What is the meaning of the coordinates?

```{r collapse=TRUE}
dem@bbox
```


What is the Spatial Reference System (SRS)?

[= Coordinate Reference System (CRS)]


*** =right

<div style='text-align: center;'>
    <img height='460' src='https://upload.wikimedia.org/wikipedia/commons/1/15/MercTranSph.png' />
</div>

<div style="font-size:10px">By <a href="//commons.wikimedia.org/wiki/User:Peter_Mercator" title="User:Peter Mercator">Peter Mercator</a> - <span class="int-own-work" lang="en">Own work</span>, Public Domain, https://commons.wikimedia.org/w/index.php?curid=9910926</div>

--- &twocol

## 1.1 Where is the DEM?

*** =left

What is the meaning of the coordinates?

```{r collapse=TRUE}
dem@bbox
```


What is the Spatial Reference System (SRS)?

[= Coordinate Reference System (CRS)]


*** =right

<div style='text-align: center;'>
    <img height='520' src='https://upload.wikimedia.org/wikipedia/de/1/12/Gau%C3%9F-Kr%C3%BCger-Raster_Deutschland.png' />
</div>

<div style="font-size:10px">Von <a href="//de.wikipedia.org/wiki/Benutzer:BerndH" title="Benutzer:BerndH">BerndH</a> - selbst erstellt mit Generic Mapping Tools (psbasemap, psxy), Python, GIMP, <a title="Creative Commons Namensnennung-Weitergabe unter gleichen Bedingungen Unported 3.0" href="http://creativecommons.org/licenses/by-sa/3.0/legalcode">CC BY-SA 3.0</a>, https://de.wikipedia.org/w/index.php?curid=4186798</div>


--- &twocol

## 1.2 Project DEM and plot

*** =left

https://epsg.io/5677

```{r fig.show='hide', collapse=TRUE}
dem@proj4string <- CRS("+init=epsg:5677")
is.projected(dem)
plot(dem)
```

*** =right

```{r echo=FALSE, collapse=TRUE}
plot(dem)
```

--- &twocol

## 1.2 Project DEM and plot

*** =left

Plot using `raster` package

```{r fig.show='hide', message=FALSE}
library("raster")
plot(raster(dem))
```

*** =right

```{r echo=FALSE}
plot(raster(dem))
```

--- 

## 1.3 Download point data

```{r}
download.file(
    url = "https://raw.githubusercontent.com/dakni/mhbil/master/data/meg_dw.csv",
    destfile = "meg_dw.csv")

meg_dw <- read.table(file = "meg_dw.csv",
                     header = TRUE,
                     sep = ";")
head(meg_dw)
```

---

## 1.4 Create SpatialPointsDataFrame (spdf)

```{r}
library(sp)
coordinates(meg_dw) <- ~x+y
str(meg_dw)
```

--- &twocol

## 1.5 Project spdf and plot

*** =left

```{r fig.show="hide"}
proj4string(meg_dw) <- CRS("+init=epsg:5677")
is.projected(meg_dw)
plot(raster(dem))
points(meg_dw)     
```

*** =right

```{r echo=FALSE}
plot(raster(dem))
points(meg_dw)
```

---

## Content

1. Prerequisites: load data into R, calculate simple geomorphometric measures
2. **Euclidean distance**
3. Least-cost distance

---


## 2 Euclidean distance 1

Distance between points using Euclidean distance with our own function

$$d(i,j) = \sqrt{(x_i-x_j)^2 + (y_i-y_j)^2}$$

```{r}
meg_dw@coords[1,]

e.d <- function(x1,x2){
    ed <- sqrt((x1[1]-x2[1])^2 + (x1[2]-x2[2])^2)
    return(ed)
    }             
ed1 <- e.d(meg_dw@coords[1,],meg_dw@coords[2,])
ed1
```

---

## 2 Euclidean distance 2

Distance between points using Euclidean distance using package `rgeos`

```{r}
library(rgeos)
gDistance(spgeom1 = meg_dw[meg_dw@data$id==1,],
          spgeom2 = meg_dw[meg_dw@data$id==2,])

ed2 <- gDistance(spgeom1 = meg_dw,
          byid = TRUE)
ed2[2]
ed1==ed2[2]
```

--- &twocol

## 2 Euclidean distance 2

*** =left

```{r, fig.show="hide", message= FALSE}
class(ed2)
str(ed2)

library(fields)
image.plot(ed2)
```

*** =right

```{r echo=FALSE}
image.plot(ed2)
```

---

## 2 Euclidean distance 2

```{r}
min(ed2)
```

```{r}
round(data.frame(min = min(ed2[ed2>0]),
                 max = max(ed2[ed2>0]),
                 mean = mean(ed2[ed2>0]),
                 median = median(ed2[ed2>0])
                 ),
      2)
```


--- &twocol

## 2 Euclidean distance 2

*** =left

```{r fig.show="hide"}
hist(ed2)
abline(v = mean(ed2[ed2>0]), col = "red")
abline(v = median(ed2[ed2>0]), col = "blue")
```

*** =right

```{r echo=FALSE}
hist(ed2)
abline(v = mean(ed2[ed2>0]), col = "red")
abline(v = median(ed2[ed2>0]), col = "blue")
```

--- &twocol

## 2 Euclidean distance 2

Some further questions that might be interesting

*** =left

```{r fig.show="hide"}
mp <- apply(X = ed2,
            MARGIN = 2,
            FUN = mean)

tmp <- ed2
tmp[tmp==0] <- 9999

cp <- apply(X = tmp,
            MARGIN = 2,
            FUN = min)

meg_dw$mp <- mp
meg_dw@data$cp <- cp
```

*** =right

What is the mean euclidean distance from a point to its surrounding points (mp)?

What is the closest euclidean distance from a point to its surrounding points (cp)?

Write the result in the attribute table of our spdf

**Question:** Why changing 0 to 9999?

--- &twocol

## 2 Euclidean distance 2

Examples how to use `spplot`: http://rspatial.r-forge.r-project.org/gallery/

*** =left

```{r out.width="450px"}
spplot(meg_dw, "cp")
```

*** =right

```{r out.width="450px"}
spplot(meg_dw, "mp")
```

---

## 2 Euclidean distance 2

Leaflet in `R`: https://rstudio.github.io/leaflet/

```{r eval=FALSE}
library(leaflet)
tmp <- spTransform(meg_dw, CRSobj = CRS("+init=epsg:4326"))
leaflet(data=tmp$cp) %>%
    addTiles() %>%
    addCircleMarkers(lng = tmp@coords[,1],
                     lat = tmp@coords[,2],
                     radius = tmp$mp/1000,
                     )
```

---

## 2 Euclidean distance 2

`Mapview` [as alternative to `leaflet`]: http://environmentalinformatics-marburg.github.io/mapview/introduction.html

```{r eval=FALSE}
library(mapview)
mapview(meg_dw, zcol = "mp", legend = TRUE)
```

---


## Questions? 


---

## Content

1. Prerequisites: load data into R, calculate simple geomorphometric measures
2. Euclidean distance
3. **Least-cost distance**

---

## 3 Least cost distance

What are the necessary steps?

1. Create cost surface
2. Create transition matrix, i.e. matrix recording connections between cells
3. Transition matrix is filled with conductance, rather than resistance values; hence unconnected cells have value 0 (= no conductance); memory efficient
4. Geocorrection of values
5. Identify adjacent cells
6. Calculate walking speed for adjacent cells
7. Geocorrect speed values
8. Find path using least-cost ("as the wolf runs") or random walk ("drunkard's walk") algorithm


--- &twocol

## 3 Least cost distance


*** =left

We use the `gdistance` package by Jacob van Etten (https://cran.r-project.org/web/packages/gdistance)

First we calculate the slope, as this is used as cost

```{r message=FALSE, fig.show="hide"}
library(raster)
dem <- raster(dem)
slope <- terrain(x = dem,
                 opt = "slope",
                 neighbors = 8,
                 unit = "degrees")
plot(slope)
##drawExtent()
crop.extent <- extent(c(3551000,3578650,6022770,6045000))
slope <- crop(x = slope, y = crop.extent)
```

*** =right

```{r echo=FALSE}
plot(slope)
```

--- 

## 3 Least cost distance

*** =left

We need to get rid of the ocean areas since it is not crossable (by foot)

- get land areas
- reproject them
- mask the slope
- reproject and factorize
- create uncrossable transition area


*** =right

```{r}
ab <- getData("GADM", country = "DEU", level = 1)
ab <- spTransform(ab, CRSobj = CRS("+init=epsg:5677"))
slope <- mask(slope, mask = ab, updatevalue = 9999)
```

---

## 3 Least cost distance

Afterwards we create the transition object and geocorrect it

```{r message=FALSE}
library(gdistance)
slope.tran <- transition(x = slope,
                         transitionFunction = mean,
                         directions = 8,
                         symm = TRUE)

slope.geo <- geoCorrection(x = slope.tran, scl = TRUE)
```

To see how the results look like we create a raster stack for easy plotting

```{r message=FALSE, fig.show = "hide"}
slopes <- stack(slope,
                raster(slope.tran),
                raster(slope.geo))
names(slopes) <- c("Slope","Transition","Geocorrection")
plot(slopes, nr = 1)
```

--- &twocol

## 3 Least cost distance

Now, the final step. Calculate Tobler's hiking speed, geocorrect again and calculate a shortest path

*** =left

```{r message=FALSE, fig.show = "hide"}
adj <- adjacent(x = slope,
                cells=1:ncell(slope),
                pairs=TRUE,
                directions=8)
speed <- slope.geo
speed[adj] <-  6 * exp(-3.5 * abs(slope.geo[adj] + 0.05))

speed.geo <- geoCorrection(x = speed, scl=TRUE)

sp1 <- shortestPath(x = speed.geo,
                    origin = meg_dw@coords[4,],
                    goal = meg_dw@coords[231,],
                    output = "SpatialLines")

plot(raster(speed.geo))
lines(sp1)
```

*** =right

```{r echo=FALSE}
plot(raster(speed))
lines(sp1)
```


--- 

## 3 Least cost distance

What about the "drunkard's walk"? `theta` is the level of drunkenness, i.e. the degree from which
the path randomly deviates from the shortest path

```{r message=FALSE, fig.show = "hide"}
p1 <- passage(x = speed.geo,
              origin = meg_dw@coords[4,],
              goal = meg_dw@coords[231,],
              theta = .005)              
              
p2 <- passage(x = speed.geo,
              origin = meg_dw@coords[4,],
              goal = meg_dw@coords[231,],
              theta = .05)

hs <-  hillShade(slope = terrain(x = dem*10, opt = "slope"),
                 aspect = terrain(x = dem, opt = "aspect"),
                 angle = 40, direction = 270)

plot(hs, col=grey(0:100/100), legend=FALSE)
plot(p1, alpha = .5, add=TRUE); lines(sp1)
```

--- &twocol

## 3 Least cost distance

*** =left

theta = .005

```{r echo=FALSE}
plot(hs, col=grey(0:100/100), legend=FALSE)
plot(p1, alpha = .5, add=TRUE)
lines(sp1)
```

*** =right

theta = .05

```{r echo=FALSE}
plot(hs, col=grey(0:100/100), legend=FALSE)
plot(p2, alpha = .5, add=TRUE)
lines(sp1)
```

---

## 3 The prehistoric "Autobahn"

Run the code and get some coffee... a lot of coffee

```{r message=FALSE, results="hide", fig.show="hide"}
xy <- data.frame(X = meg_dw@coords[,1],
                 Y = meg_dw@coords[,2])

rows.xy <- row.names(xy)
sa.rows.xy <- sample(row.names(xy), length(xy$X)/2)
starts <- subset(xy, rows.xy %in% sa.rows.xy)
goals <- subset(xy, !(rows.xy %in% sa.rows.xy))
sg.passages <- brick(slope)

for(i in 1:length(starts$X)) {
    s <- c(starts$X[i],starts$Y[i])
    z <- c(goals$X[i],goals$Y[i])
    sg.passages[[i]] <- passage(x = speed.geo, origin = s, goal = z, theta = .05) 
    cat("iteration ", i, " of ", length(starts$X),"\n")
}

sg.passages.sum <- sum(sg.passages)
```

--- &twocol 

## 3 The prehistoric "Autobahn"

*** =left

```{r fig.show="hide"}
plot(hs, col=grey(0:100/100), legend=FALSE)

plot(sg.passages.sum,
     col = colorRampPalette(colors = c("white","red"))(50),
     alpha = .5,
     add=TRUE)

points(meg_dw,
       pch = 19,
       col = rgb(red = 0, green = 0, blue = 0, alpha = .2))
```

*** =right

```{r echo=FALSE}
plot(hs, col=grey(0:100/100), legend=FALSE)
plot(sg.passages.sum,
     col = colorRampPalette(colors = c("white","red"))(50),
     alpha = .8,
     add=TRUE)
points(meg_dw,
       pch = 19,
       col = rgb(red = 0, green = 0, blue = 0, alpha = .2))
```
